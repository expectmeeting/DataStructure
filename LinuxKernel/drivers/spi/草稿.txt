//分析spi-gpio.c
//该.c文件实现了一个平台驱动，即spi_gpio_driver
//在驱动与设备完成匹配后，会执行探测函数，即spi_gpio_probe
//分析该函数中，重要的调用过程：
1、status = spi_gpio_probe_dt(pdev);
该函数目的是，分配一块内存空间，保存着SPI设备树节点中片选属性的值，并将
platform_device结构对象中的device结构对象中的空指针对象platform_data指向该空间。
|--spi_gpio_probe_dt  
  |--of_match_device 再次核对是否驱动与设备相匹配，并返回spi_gpio_probe_dt数组中最匹配的项
  |--devm_kzalloc() 分配内存空间，并将其与平台设备中device对象关联，达到动态释放的目的
  |--of_property_read_u32 从设备节点device_node对象中读取与指定属性名对应的属性值，成功返回0
  |--以上全部执行成功返回1，失败则释放分配的内存，并返回

2、dev_get_platdata(&pdev->dev)
该函数目的为得到驱动平台数据
static int spi_gpio_probe(struct platform_device *pdev)
{
	int				status;
	struct spi_master		*master;
	struct spi_gpio			*spi_gpio;
	struct spi_gpio_platform_data	*pdata;
	u16 master_flags = 0;
	bool use_of = 0;

	status = spi_gpio_probe_dt(pdev);
	if (status < 0)
		return status;
	if (status > 0)
		use_of = 1;

	pdata = dev_get_platdata(&pdev->dev);
#ifdef GENERIC_BITBANG
	if (!pdata || (!use_of && !pdata->num_chipselect))
		return -ENODEV;
#endif

	master = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio));
	if (!master)
		return -ENOMEM;

	spi_gpio = spi_master_get_devdata(master);

	spi_gpio->cs_gpios = devm_kcalloc(&pdev->dev,
				pdata->num_chipselect,
				sizeof(*spi_gpio->cs_gpios),
				GFP_KERNEL);
	if (!spi_gpio->cs_gpios)
		return -ENOMEM;

	platform_set_drvdata(pdev, spi_gpio);

	/* Determine if we have chip selects connected */
	spi_gpio->has_cs = !!pdata->num_chipselect;

	spi_gpio->pdev = pdev;
	if (pdata)
		spi_gpio->pdata = *pdata;

	status = spi_gpio_request(&pdev->dev, spi_gpio,
				  pdata->num_chipselect, &master_flags);
	if (status)
		return status;

	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
	master->mode_bits = SPI_3WIRE | SPI_CPHA | SPI_CPOL;
	master->flags = master_flags;
	master->bus_num = pdev->id;
	/* The master needs to think there is a chipselect even if not connected */
	master->num_chipselect = spi_gpio->has_cs ? pdata->num_chipselect : 1;
	master->setup = spi_gpio_setup;
	master->cleanup = spi_gpio_cleanup;
#ifdef CONFIG_OF
	master->dev.of_node = pdev->dev.of_node;
#endif

	spi_gpio->bitbang.master = master;
	spi_gpio->bitbang.chipselect = spi_gpio_chipselect;
	spi_gpio->bitbang.set_line_direction = spi_gpio_set_direction;

	if ((master_flags & SPI_MASTER_NO_TX) == 0) {
		spi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_word_mode0;
		spi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_word_mode1;
		spi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_word_mode2;
		spi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_word_mode3;
	} else {
		spi_gpio->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_spec_txrx_word_mode0;
		spi_gpio->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_spec_txrx_word_mode1;
		spi_gpio->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_spec_txrx_word_mode2;
		spi_gpio->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_spec_txrx_word_mode3;
	}
	spi_gpio->bitbang.setup_transfer = spi_bitbang_setup_transfer;
	spi_gpio->bitbang.flags = SPI_CS_HIGH;

	status = spi_bitbang_start(&spi_gpio->bitbang);
	if (status)
		spi_master_put(master);

	return status;
}