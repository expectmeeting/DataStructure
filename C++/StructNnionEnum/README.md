[TOC]

# 结构体

结构体类型变量的一般定义为

~~~c++
struct 结构体类型名{
	类型名1	成员名1；
	类型名2	成员名2；
	…
	类型名n	成员名n；
结构体类型名(类型名1 形参1，类型名2 形参2，…，类型名n 形参n) : 成员名1 (形参1), 成员名2 (形参2)，… , 成员名n (形参n) {}
}
~~~

**结构体定义需注意以下几点**：

- （1）不允许对其自身进行递归定义，但可以使用指针指向本类型。

- （2）结构体定义中可以包含另外的结构体。

- （3）结构体变量可以在定义时进行初始化赋值。但必须依次为成员赋值，可以只给前面若干变量赋值，后面的基本类型系统会自动赋值0。

**另外**，有些信息在存储时，并不需要占用整个字节，因此C语言提供了一种数据结构，称为“**位域**”或“**位段**”。位域在定义时，其类型名为**整型或枚举**，接下来是冒号，冒号后跟数字，它指定了使用的位数。这样的成员被称为**位字段**（bit field）。

例子：

~~~c++
int iB:4;
~~~

# 共用体

- 共用体的定义与结构体的定义相差不大，采用共用体类型名union定义公用体对象。其也由多个不同的类型成员组成，但其所占内存为其成员中占用最大内存者，这也意味着共用体对象同一时间只存储其某一成员的值。**常用于检测大小端**

**共用体和结构体的存放顺序是一致的，即所有成员均由低地址开始存放**。

# 大端、小端

大端和小端均指字数据的存储格式，网络中传输的数据采用大端格式，而常见主机则一般采用小端格式。

**大端存储格式：**即多字节数据的高字节存储在低地址中，而低字节数据存放在高地址中。

**小端存储格式：**即多字节数据的高字节存储在高地址中，而低字节数据存放在低地址中。

例子：short类型的数据 0x0201=(16^2)* 2 + (16^0)* 1

**大端存储格式**

| 存放内容 | 0x02           | 0x01           |
| -------- | -------------- | -------------- |
| 内存地址 | 低地址：0x0001 | 高地址：0x0002 |

**小端存储格式**

| 存放内容 | 0x01           | 0x02           |
| -------- | -------------- | -------------- |
| 内存地址 | 低地址：0x0001 | 高地址：0x0002 |

# 位域中的大小端

在字节内部也存在大小端问题，相应的大小端定义为：

**大端存储格式：**即多位数据的高位存储在字节中的低位中，而低位数据存放在高位中，且从内存的高位开始存放。

**小端存储格式：**即多位数据的高位存储在字节中的高位中，而低位数据存放在低位中，且从内存的低位开始存放。

**注意：**若多位数据大于1byte（8bit），则先按字节序中大小端的定义分配相应大小的位数据到相应的字节中，再按位序大小端定义分配到相应的位地址。

例如：

~~~c++
struct s{
	short bit1:4;
	short bit2:9;
	short bit3:3;
};

s sA;
sA.bit1=0b3210；//此处数字(3)仅表示输入时，在字节中所处的位数(第3位，真实数据为(0或1)*2^3)
sA.bit2=0b876543210；
sA.bit3=0b210；
~~~

**大端存储格式**

![fig1](E:\Git_repository\Notes\C++\StructNnionEnum\fig1.png)

**小端存储格式**

![fig2](E:\Git_repository\Notes\C++\StructNnionEnum\fig2.png)

# sizeof运算符

- sizeof是一个**运算符**，其并**不是函数**。其以**字节形式**给出了其操作数的存储大小，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由其对应的类型决定。

**注意：**sizeof的运算发生在**编译时刻**，会忽略其括号内的各种运算，如“sizeof(a++);”中的++不执行。

 

**sizeof的使用对象**

- **函数：**sizeof 可以对一个函数调用求值，其结果是函数返回类型的大小，函数并不会调用。

如：int foo（）是一个函数，可以sizeof(foo());但不能sizeof(foo)，即函数名不能被计算。

- **字符串：** sizeof对**字符串**的计算会将结束符’\0’包含在内，例

~~~c++
sizeof(”123”)=4
sizeof(“\0”)=2//此字符串占用了两个字节\0\0，因此返回2
~~~

- **指针: ** sizeof对指针变量的计算根据所处的操作系统是多少位，64位为8,32位为4

- **引用：**等同于对被引用对象的sizeof

- **汉字：**windows下一个汉字占**两个字节**，而Linux环境中，若采用UTF-8编码则占**3个字节**
- **数组：**返回其实际占用存储空间的字节数，数组作为形参时当做指针对待。

# struct的空间计算

## 1、只含基本数据类型的成员

**空间占用原则：**

- (1):整体空间大小为占用空间最大的成员所占字节数的整数倍。（分环境，在32位Linux+gcc中，若占用空间最大的成员所占字节数超过4，则按4计算）

- (2)数据对齐原则——内存按结构体成员的先后顺序排序，当排到成员变量时，其前面已占用的空间大小必须是该成员类型大小的整数倍。

## 2、含结构体的结构体的空间计算

**空间占用原则：**

- (1): 整体空间大小为**子结构体和父结构体中**占用空间最大的成员所占字节数的整数倍。（分环境，在32位Linux+gcc中，若占用空间最大的成员所占字节数超过4，则按4计算）

- (2) 数据对齐原则——父结构体内存按结构体成员的先后顺序排序，当排到子结构体成员时，其前面已摆放的空间大小必须是该子结构体成员中最大类型大小的整数倍。（分环境，在32位Linux+gcc中，若子结构体成员中最大类型所占字节数超过4，则按4计算）

## 3、含数组的结构体的空间计算

**空间占用原则：**

- 将数组成员按其所属类型进行考虑，并不将其视为整体。

例：

~~~c++
struct s1{
	char a[8];
	int b;
}；

cout<<sizeof(s1);//12
~~~

## 4、含位域结构体的空间计算

**空间占用原则：**

- (1)如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前面一个字段存储，直到不能容纳为止。

注意：在VS环境下，一个int a:4，如果后面不是位域，则占用4个字节，而在Dev-C++以及Linux+gcc编译环境下，采用了更加节省空间的方法，即不论位域为何类型，所占字节数以其实际占用字节数为准，以方便后续结构体成员的摆放，即一个int a:4，如果后面不是位域。仅占1个字节。

- (2)如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍。

- (3)如果相邻的位域字段的类型不同，则根据相应的编码器，VS采取不压缩方式，Dev-C++与gcc采取压缩方式。

- (4)如果位域字段之间穿插着非位域字段，则不进行压缩。(针对Linux+gcc环境而言)

- (5)整个结构体的总大小为最宽基本类型成员大小的整数倍。

## 5、空结构体的大小

空结构体的大小为1.

**注意：**内存对齐规则可以通过预处理指令#pragma pack(n)进行变更，即偏移值=min(n,类型大小)，其中#pragma pack(pop)为恢复对齐状态。内存对齐的作用：提升CPU访问内存的速度。

# 6、union的空间计算

整个联合体的sizeof为每个成员sizeof的最大值，但整体空间需要为占用空间最大的成员所占字节数的整数倍。

# 7、 枚举enum的空间计算

Enum只是定义了一个常量集合，里面没有元素，而枚举类型是当做int类型存储的，故枚举类型sizeof值都为4